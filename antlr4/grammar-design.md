
> [!WARNING]
> 本专题大多内容来源于我读《ANTLR 4权威指南》的随手笔记以及个人实践，仅供参考学习，`请勿用于任何商业用途，后果自负`，如涉及侵权或有错误之处，及时 [联系本人](https://bytesfly.github.io/blog/#/about/?id=%f0%9f%92%8c-%e8%81%94%e7%b3%bb) 。

下面学习如何编写语法。

## 如何定义语法规则

一种语言模式就是一种递归的语法结构。

我们需要从一系列有代表性的输入文件中归纳出一门语言的结构。在完成这样的归纳工作后，我们就可以正式使用`ANTLR`语法来表达这门语言了。

编写语法和编写软件很相似，差异在于我们处理的是语言规则，而非函数或者过程(`procedure`)。

在深入研究语法的细节之前，一件大有裨益的事情是：**讨论语法的整体结构以及如何建立初始的语法框架**。

语法由一个为该语法命名的头部定义和一系列可以相互引用的语言规则组成。

```text
grammar MyG;
rule1: <<stuff>>;
rule2: <<more stuff>>;
...
```

设计良好的语法反映了编程世界中的功能分解或者自顶向下的设计。这意味着我们对语言结构的辨识是从最粗的粒度开始，一直进行到最详细的层次，并把它们编写成为语法规则。所以，我们的第一个任务是找到最粗粒度的语言结构，将它作为我们的起始规则。在英语中，我们可以使用`sentence`规则作为起始规则。对于一个`XML`文件，我们可以使用`document`规则作为起始规则。

设计起始规则的内容实际上就是使用`英语伪代码`来描述输入文本的整体结构，这和我们编写软件的过程有点类似。

例如，一个CSV文件就是一系列以换行符为终止的行(`a comma-separated-value file is a sequence of rows terminated by newlines`)。其中，`is a`左侧的单词`file`就是规则名，右侧的全部内容就是规则定义中的`<<stuff>>`，即：

```text
file: <<sequence of rows that are terminated by newlines>>;
```

接着，我们描述起始规则右侧所指定的那些元素。它右侧的名词通常是词法符号或者尚未定义的规则。其中，词法符号是那些我们的大脑能够轻易识别出的单词、标点符号或者运算符。正如英语语句中的单词是最基本元素一样，词法符号是文法的基本元素。起始规则引用了其他的、需要进一步细化的语言结构， 如上面的例子中的“行”`row`。

一个行就是一系列由逗号分隔的字段（`a row is a sequence of fields separated by commas`）。接下来，一个字段就是一个数字或者字符串（`a field is a number or string`）。我们的伪代码如下所示：

```text
file: <<sequence of rows that are terminated by newlines>> ;
row: <<sequence of fields separated by commas>> ;
field: <<number or string>> ;
```

当我们完成对规则的定义后，我们的语法草稿就成形了。在刚开始的时候，辨识一条语法规则并使用伪代码编写右侧的内容是一项充满挑战的工作，不过，它会随着你为不同语言编写语法的过程变得越来越容易。


## 使用ANTLR语法表达语言

现在我们拥有了伪代码，还需要将它翻译为`ANTLR`标记，从而得到一个能够正常工作的语法。

常见的语言模式包括：序列(`sequence`)、选择(`choice`)、词法符号依赖(`token dependency`)，以及嵌套结构(`nested phrase`)。

在之前的 [快速上手](antlr4/quick-start.md) ，我们见过这些模式的一些例子。随着学习的深入，我们会用正式的语法规则将特定的模式表达出来，通过这种方式，我们就能够掌握基本的`ANTLR`标记的用法。

### 序列模式

登录一台POP服务器并获取第一条消息的指令序列为：

```text
USER parrt
PASS secret
RETR 1
```

其中指令`RETR 1`是由`RETR`关键字(保留字)，一个操作数和一个换行符构成。

使用`ANTLR`语法来表述这样的序列，只需要按照顺序将它们列出即可：

````antlrv4
retr : 'RETR' INT '\n' ; // 匹配“关键字－整数－换行符”序列
INT :   [0-9]+ ;
WS  :   [ \t]+ -> skip ;
````

注意，可以直接使用类似`'RETR'`的常量字符串来表示任意简单字符序列，诸如关键字或者标点符号等。

使用语法规则来为编程语言的特定结构命名，这就好像我们在编程时将若干个语句组合成一个函数。在上例中，我们将`RETR`命名为`retr`规则。这样，在语法的其他地方，就可以直接把规则名作为简称来引用`RETR`。

序列模式的变体包括：
- 带终止符的序列模式
- 带分隔符的序列模式

CSV文件同时使用了这两种模式。上面我们定义出了CSV文件的语法规则，下面用`ANTLR`语法来表达：

```antlrv4
file : (row '\n')* ; // 以换行符作为终止符的序列
row : field (',' field)* ; // 以','作为分隔符的序列
field: INT | STRING ;
```

简单解释一下：

- `file`规则使用带终止符的序列模式来匹配零个或多个`row'\n'`序列。其中序列中的每个元素都以`\n`字符结束；
- `row`规则使用带分隔符的序列模式来匹配一个`field`后面跟着零个或多个`'，'field`序列的情形。 `,`隔开了所有的`field`；

### 选择模式

在`ANTLR`的规则中，使用`|`符号表示`或者`的含义，称作备选分支(`alternatives`)。

比如上面CSV语法中用到的`field: INT | STRING ;`，表示字段可以是整数或者字符串。

上文 [快速上手的四则运算案例](antlr4/quick-start.md#使用Visitor构建计算器) 中，就用到了选择模式，如下：

```antlrv4
stat:   expr NEWLINE                # printExpr
    |   ID '=' expr NEWLINE         # assign
    |   NEWLINE                     # blank
    ;

expr:   expr op=('*'|'/') expr      # MulDiv
    |   expr op=('+'|'-') expr      # AddSub
    |   INT                         # int
    |   ID                          # id
    |   '(' expr ')'                # parens
    ;
```

也就是说，当语法规则中有允许这样也允许那样的含义时，就能使用`选择模式`。

### 词法符号依赖模式

如果在某个语句中看到了某个符号，就必须在同一个语句中找到和它配对的另外一个符号。为表达出这种语义，在语法中，我们使用一个序列来指明所有配对的符号，通常这些符号会把其他元素分组或者包裹起来。

上文 [快速上手的数组转换案例](antlr4/quick-start.md#使用Listener转换数组) 中，就用到了词法符号依赖模式，如下：

```antlrv4
/** A rule called init that matches comma-separated values between {...}. */
init  : '{' value (',' value)* '}' ;  // must match at least one value
```

### 嵌套模式

如果一条语法规则定义中的伪代码引用了它自身，就需要一条递归规则（自引用规则）。

上文 [快速上手的四则运算案例](antlr4/quick-start.md#使用Visitor构建计算器) 中，也用到了递归，如下：

```antlrv4
expr:   expr op=('*'|'/') expr      # MulDiv
    |   expr op=('+'|'-') expr      # AddSub
    |   INT                         # int
    |   ID                          # id
    |   '(' expr ')'                # parens
    ;
```

语言结构上的递归自然而然地使得语言规则发生了递归。

### 总结

<br/>

| 语言模式                                                     | 描述 |
| ------------------------------------------------------------ | -------- |
| 序列模式 | 它是一个有限长度或者任意长度的序列，序列中的元素可以是词法符号或者子规则。序列模式的例子包括变量声明（类型后面紧跟着标识符）和整数序列，例子：<br/> `retr : 'RETR' INT NEWLINE ; // 匹配“关键字－整数－换行符”序列`     |
| 带终止符的序列模式 | 它是一个任意长的、可能为空的序列，该序列由一个词法符号分隔开，通常是分号或者换行符，其中的元素可以是词法符号或者子规则。这样的例子包括类Java语言的语句集合和一些用换行符来分隔的数据格式。例子：<br/> `(statement ';')*  // Java的语句集合`  <br/> `(row NEWLINE)* // 多行数据`  | 
| 带分隔符的序列模式 | 它是一个任意长的、可能为空的序列，该序列由一个词法符号分隔开，通常是逗号、分号或是句号，其中的元素可以是词法符号或者子规则。这样的例子包括函数定义中的参数表、函数调用时传递的参数表、某些语句之间有分隔符却无终止符的编程语言，以及目录名。举例：    |
| 选择模式 | 待完善    |
| 词法符号依赖模式 | 待完善    |
| 嵌套模式 | 待完善    |

## 常见的词法结构

和语法分析器一样，词法分析器也使用规则来描述种类繁多的语言结构。在`ANTLR`中，我们使用的是几乎完全相同的标记。唯一的差别在于，语法分析器通过输入的词法符号流来识别特定的语言结构，而词法分析器通过输入的字符流来识别特定的语言结构。

由于词法规则和文法规则的结构相似，`ANTLR`允许二者在同一个语法文件中同时存在。不过，由于词法分析和语法分析是语言识别过程中的两个不同阶段，我们必须告诉`ANTLR`每条规则对应的阶段。它是通过这种方式完成的：

> 词法规则以大写字母开头，而文法规则以小写字母开头。

例如，`ID`是一个词法规则名，而`expr`是一个文法规则名。

对于关键字、运算符和标点符号，我们无须声明词法规则，只需要在文法规则中直接使用单引号将它们括起来即可，例如`'while'`、`'*'`，以及`'++'`。有些开发者更愿意使用类似`MULT`的词法规则来引用`'*'`，以避免对其的直接使用。这样，在改变乘法运算符的时候，只需修改`MULT`规则，而无须逐个修改引用了`MULT`的文法规则。

下面看下常见的词法结构。


| 词法符号类型       | 举例 |
| ----------------| -------- |
| 匹配标识符 | `ID : [a-zA-Z]+ ; // 匹配1个或多个大小写字母` |
| 嵌套模式 | 待完善    |
| 词法符号依赖模式 | 待完善    |
| 嵌套模式 | 待完善    |

其他：

```antlrv4
ID : ('a'..'z'|'A'..'Z')+ ; // 匹配1个或多个大小写字母
```
这个让我们感到新鲜的是范围运算符：'a'..'z'，它的意思是从a到z的所有字符。

